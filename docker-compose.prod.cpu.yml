# Docker Compose配置 - 生产环境
# 用于生产环境部署，包含所有服务的容器化配置
# 包括：PostgreSQL, Redis, RabbitMQ, Backend, Frontend, AI-Processor

services:
    # PostgreSQL数据库
    postgres:
        image: postgres:17.6-alpine
        container_name: var-postgres-prod
        restart: always
        env_file:
            - .env # 使用根目录的.env文件（通过scripts/use-env.ps1生成）
        environment:
            POSTGRES_DB: ${DB_NAME}
            POSTGRES_USER: ${DB_USER}
            POSTGRES_PASSWORD: ${DB_PASSWORD}
            PGDATA: /var/lib/postgresql/data/pgdata
            LANG: en_US.utf8
            LC_ALL: en_US.utf8
        ports:
            - "${DB_PORT}:5432"
        volumes:
            - ./storage/postgres-data:/var/lib/postgresql/data
        healthcheck:
            test: ["CMD-SHELL", "pg_isready -U ${DB_USER} -d ${DB_NAME}"]
            interval: 10s
            timeout: 5s
            retries: 5
        networks:
            - var-network

    # Redis缓存
    redis:
        image: redis:8.2.1-alpine
        container_name: var-redis-prod
        restart: always
        env_file:
            - .env # 使用根目录的.env文件（通过scripts/use-env.ps1生成）
        command: redis-server --requirepass ${REDIS_PASSWORD} --appendonly yes
        ports:
            - "${REDIS_PORT}:6379"
        volumes:
            - ./storage/redis-data:/data
        healthcheck:
            test: ["CMD", "redis-cli", "--raw", "incr", "ping"]
            interval: 10s
            timeout: 3s
            retries: 5
        networks:
            - var-network

    # RabbitMQ消息队列
    rabbitmq:
        image: rabbitmq:4.1.4-management-alpine
        container_name: var-rabbitmq-prod
        restart: always
        env_file:
            - .env # 使用根目录的.env文件（通过scripts/use-env.ps1生成）
        environment:
            RABBITMQ_DEFAULT_USER: ${RABBITMQ_USER}
            RABBITMQ_DEFAULT_PASS: ${RABBITMQ_PASSWORD}
            RABBITMQ_DEFAULT_VHOST: ${RABBITMQ_VHOST}
        ports:
            - "${RABBITMQ_PORT}:5672"
            - "15672:15672"
        volumes:
            - ./storage/rabbitmq-data:/var/lib/rabbitmq
        healthcheck:
            test: ["CMD", "rabbitmq-diagnostics", "ping"]
            interval: 10s
            timeout: 5s
            retries: 5
        networks:
            - var-network

    # 后端服务
    backend:
        build:
            context: ./backend
            dockerfile: Dockerfile
        image: var-backend:latest
        container_name: var-backend-prod
        restart: always
        env_file:
            - ./backend/.env # backend模块的环境变量文件
        ports:
            - "8080:8080"
        volumes:
            # 共享存储卷,用于存储上传的视频和处理结果
            - ./storage:/app/storage
        depends_on:
            postgres:
                condition: service_healthy
            redis:
                condition: service_healthy
            rabbitmq:
                condition: service_healthy
        healthcheck:
            test: ["CMD", "curl", "-f", "http://localhost:8080/actuator/health"]
            interval: 30s
            timeout: 3s
            start_period: 60s
            retries: 3
        networks:
            - var-network

    # AI处理模块
    ai-processor:
        build:
            context: ./ai-processor
            dockerfile: Dockerfile.cpu
        image: var-ai-processor-cpu:latest
        container_name: var-ai-processor-prod
        restart: always
        env_file:
            - ./ai-processor/.env # ai-processor模块的环境变量文件
        ports:
            - "5000:5000"
        volumes:
            # 共享存储卷,用于读取视频和写入处理结果
            - ./storage:/app/storage
            # 挂载模型权重文件（只读）
            - ./ai-processor/weights:/app/ai-processor/weights:ro
            # 临时目录（内存文件系统，提高安全性）
            - type: tmpfs
              target: /tmp
              tmpfs:
                  size: 1073741824 # 1GB
        depends_on:
            postgres:
                condition: service_healthy
            redis:
                condition: service_healthy
            rabbitmq:
                condition: service_healthy
            backend:
                condition: service_healthy
        healthcheck:
            test: ["CMD", "curl", "-f", "http://localhost:5000/health"]
            interval: 30s
            timeout: 3s
            start_period: 90s
            retries: 3
        networks:
            - var-network
        # ========================================
        # 容器安全加固配置
        # ========================================
        security_opt:
            # 禁止新权限（防止提权攻击）
            - no-new-privileges:true
            # 使用 seccomp 安全配置（限制系统调用）
            - seccomp:unconfined # 生产环境建议使用自定义 seccomp 配置文件
        cap_drop:
            # 移除所有 Linux capabilities（最小权限原则）
            - ALL
        cap_add:
            # 只添加必需的 capabilities
            - CHOWN # 修改文件所有者（日志目录等）
            - DAC_OVERRIDE # 绕过文件权限检查（必需）
            - SETGID # 设置 GID（切换用户组）
            - SETUID # 设置 UID（切换用户）
        # 只读根文件系统（提高安全性）- 注意：需要确保所有写入都在 volumes 或 tmpfs 中
        # read_only: true  # 如果启用，需要添加更多 tmpfs 挂载点
        # ========================================
        # CPU模式（不使用GPU）
        # ========================================
        # 如果有GPU，可以使用 docker-compose.prod.yml 配置文件

    # 前端服务
    frontend:
        build:
            context: ./frontend
            dockerfile: Dockerfile
        image: var-frontend:latest
        container_name: var-frontend-prod
        restart: always
        ports:
            - "8848:8848"
        depends_on:
            backend:
                condition: service_healthy
        healthcheck:
            test:
                [
                    "CMD",
                    "wget",
                    "--no-verbose",
                    "--tries=1",
                    "--spider",
                    "http://localhost:8848/",
                ]
            interval: 30s
            timeout: 3s
            start_period: 15s
            retries: 3
        networks:
            - var-network

# 网络配置
networks:
    var-network:
        name: var-network-prod
        driver: bridge
